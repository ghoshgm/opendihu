#!/usr/bin/env ../../../dependencies/python/install/bin/python3
# -*- coding: utf-8 -*-
#
# This scripts reads a fibers.bin file which is generated by opendihu parallel_fiber_estimation. It outputs a stl file and a pickle file containing all fibers.
#
# usage: ./read_mpi_fibers.py [<input filename> [<mesh output filename> [<pickle output filename]]]

import sys, os
import numpy as np
import struct
import stl
from stl import mesh
import datetime
import pickle

input_filename = "fibers.bin"

if len(sys.argv) >= 2:
  input_filename = sys.argv[1]

output_filename = "{}.stl".format(input_filename)
  
if len(sys.argv) >= 3:
  output_filename = sys.argv[2]
output_filename2 = output_filename+"_"
  
pickle_output_filename = "{}.pickle".format(input_filename)
if len(sys.argv) == 4:
  pickle_output_filename = sys.argv[3]
pickle_output_filename2 = pickle_output_filename+"_"
  
print("{} -> {}, {}".format(input_filename, output_filename, pickle_output_filename))

with open(input_filename, "rb") as infile:
  
  # parse header
  bytes_raw = infile.read(32)
  header_str = struct.unpack('32s', bytes_raw)[0]
  print("header: {}".format(header_str))
  
  header_length_raw = infile.read(4)
  header_length = struct.unpack('i', header_length_raw)[0]
  #header_length = 32+8
  parameters = []
  for i in range(int(header_length/4) - 1):
    int_raw = infile.read(4)
    value = struct.unpack('i', int_raw)[0]
    parameters.append(value)
    
  n_fibers_total = parameters[0]
  n_points_whole_fiber = parameters[1]
  
  print("nFibersTotal:      {n_fibers} = {n_fibers_x} x {n_fibers_x}".format(n_fibers=parameters[0], n_fibers_x=(int)(np.sqrt(parameters[0]))))
  print("nPointsWholeFiber: {}".format(parameters[1]))
  print("nBorderPointsXNew: {}".format(parameters[2]))
  print("nBorderPointsZNew: {}".format(parameters[3]))
  print("nFineGridFibers_:  {}".format(parameters[4]))
  print("nRanks:            {}".format(parameters[5]))
  print("nRanksZ:           {}".format(parameters[6]))
  print("nFibersPerRank:    {}".format(parameters[7]))
  print("date:              {:%d.%m.%Y %H:%M:%S}".format(datetime.datetime.fromtimestamp(parameters[8])))
  
  input("Press any key to continue.")
  
  streamlines = []
  n_streamlines_valid = 0
  n_streamlines_invalid = 0
  for streamline_no in range(n_fibers_total):
    streamline = []
    streamline_valid = True
    for point_no in range(n_points_whole_fiber):
      point = []
      for i in range(3):
        double_raw = infile.read(8)
        value = struct.unpack('d', double_raw)[0]
        point.append(value)
      if point[0] == 0.0 and point[1] == 0.0 and point[2] == 0.0:
        if streamline_valid:
          print("Error: streamline {} is invalid ({}. point)".format(streamline_no, point_no))
        streamline_valid = False
      streamline.append(point)
    if streamline_valid:
      n_streamlines_valid += 1
    else:
      n_streamlines_invalid += 1
      streamline = []
    streamlines.append(streamline)
  
  print("n valid: {}, n invalid: {}".format(n_streamlines_valid, n_streamlines_invalid))
  print("output pickle to filename: {}".format(pickle_output_filename))
  with open(pickle_output_filename, 'wb') as f:
    pickle.dump(streamlines, f)
  print("done")
    
  triangles = []
  for points in streamlines:
    previous_point = None
    
    for p in points:
      point = np.array([p[0], p[1], p[2]])
      if np.linalg.norm(point) < 1e-3:
        continue
      if previous_point is not None:
        triangles.append([previous_point, point, 0.5*(previous_point+point)])
      previous_point = point

  #---------------------------------------
  # Create the mesh
  out_mesh = mesh.Mesh(np.zeros(len(triangles), dtype=mesh.Mesh.dtype))
  for i, f in enumerate(triangles):
    out_mesh.vectors[i] = f
  #out_mesh.update_normals()

  out_mesh.save(output_filename)
  print("saved {} triangles to \"{}\"".format(len(triangles),output_filename))
  
  print("postprocessing where fibres with too high distance to neighbouring fibers are removed (may take long)")
  input("Press any key to continue.")
  
  
  # postprocess streamlines
  invalid_streamlines = []
  n_fibers_x = (int)(np.sqrt(n_fibers_total))
  for j in range(0,n_fibers_x):
    for i in range(0,n_fibers_x):
      fiber_no = j*n_fibers_x + i
      
      fiber_no_0minus = None
      fiber_no_0plus = None
      fiber_no_1minus = None
      fiber_no_1plus = None
      if i > 0:
        fiber_no_0minus = j*n_fibers_x + i-1
      if i < n_fibers_x-1:
        fiber_no_0plus = j*n_fibers_x + i+1
      if j > 0:
        fiber_no_1minus = (j-1)*n_fibers_x + i
      if j < n_fibers_x-1:
        fiber_no_1plus = (j+1)*n_fibers_x + i
      
      average_distance = 0
      max_distance = 0
      n_points = 0
      for point_no in range(n_points_whole_fiber):
        if len(streamlines[fiber_no]) > point_no:
          if fiber_no_0minus is not None:
            if len(streamlines[fiber_no_0minus]) > point_no:
              #average_distance += np.linalg.norm(np.array(streamlines[fiber_no][point_no]) - np.array(streamlines[fiber_no_0minus][point_no]))
              max_distance = max(max_distance, np.linalg.norm(np.array(streamlines[fiber_no][point_no]) - np.array(streamlines[fiber_no_0minus][point_no])))
              n_points += 1
          if fiber_no_1minus is not None:
            if len(streamlines[fiber_no_1minus]) > point_no:
              #average_distance += np.linalg.norm(np.array(streamlines[fiber_no][point_no]) - np.array(streamlines[fiber_no_1minus][point_no]))
              max_distance = max(max_distance, np.linalg.norm(np.array(streamlines[fiber_no][point_no]) - np.array(streamlines[fiber_no_1minus][point_no])))
              n_points += 1
          if fiber_no_0plus is not None:
            if len(streamlines[fiber_no_0plus]) > point_no:
              #average_distance += np.linalg.norm(np.array(streamlines[fiber_no][point_no]) - np.array(streamlines[fiber_no_0plus][point_no]))
              max_distance = max(max_distance, np.linalg.norm(np.array(streamlines[fiber_no][point_no]) - np.array(streamlines[fiber_no_0plus][point_no])))
              n_points += 1
          if fiber_no_1plus is not None:
            if len(streamlines[fiber_no_1plus]) > point_no:
              #average_distance += np.linalg.norm(np.array(streamlines[fiber_no][point_no]) - np.array(streamlines[fiber_no_1plus][point_no]))
              max_distance = max(max_distance, np.linalg.norm(np.array(streamlines[fiber_no][point_no]) - np.array(streamlines[fiber_no_1plus][point_no])))
              n_points += 1
      #if n_points > 0:
        #average_distance /= n_points
      print (" fiber {},{}, average_distance: {}, n_points: {}, max_distance: {}".format(i,j,average_distance, n_points, max_distance))
      if max_distance > 10:
        invalid_streamlines.append(fiber_no)
  
  for invalid_streamline_no in invalid_streamlines:
    streamlines[invalid_streamline_no] = []


  print("output other pickle to filename: {}".format(pickle_output_filename2))
  with open(pickle_output_filename2, 'wb') as f:
    pickle.dump(streamlines, f)
  
  #streamlines = [streamlines[5]]
  #print(streamlines[0])
  
  triangles = []
  for points in streamlines:
    previous_point = None
    
    for p in points:
      point = np.array([p[0], p[1], p[2]])
      if np.linalg.norm(point) < 1e-3:
        continue
      if previous_point is not None:
        triangles.append([previous_point, point, 0.5*(previous_point+point)])
      previous_point = point

  #---------------------------------------
  # Create the mesh
  out_mesh = mesh.Mesh(np.zeros(len(triangles), dtype=mesh.Mesh.dtype))
  for i, f in enumerate(triangles):
    out_mesh.vectors[i] = f
  #out_mesh.update_normals()

  out_mesh.save(output_filename2)
  print("saved {} triangles to \"{}\"".format(len(triangles),output_filename2))
